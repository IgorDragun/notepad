# Подключим встроенный в Ruby класс Date для работы с датами
require 'date'

class Task < Post

  # Определим конструктор класса
  def initialize
    # Вызовем конструктор родительского класса
    super
    # Дополнительно инициализируем специфичное для этого класса поле
    @due_date = ""
  end


  # Метод для считывания ввода от пользователя и записи его в нужные поля объекта
  # Переопределяем метод родительского класса
  def read_from_console
    # Спрсим у пользователя, какую задачу ему нужно решить (одной строчки будет достаточно)
    puts "Что Вам необходимо сделать?"
    @text = STDIN.gets.chomp
    # Спрсим у пользователя, до какого числа ему нужно это сделать
    puts "До какого числа Вам необходимо это сделать?"
    puts "Укажите дату в формате ДД.ММ.ГГГГ, например 20.06.2022."
    input_date = STDIN.gets.chomp
    # Перепише дату в удобном формате
    @due_date = Date.parse(input_date)
  end


  # Метод для подготовки данных и возврата состояния объекта в виде массива строк для записи в файл
  # Переопределяем метод родительского класса
  def to_strings
    time_string = "Создано: #{@created_at.strftime("%Y.%m.%d, %H:%M")}.\n\r"
    deadline = "Сделать до #{@due_date.strftime("%Y.%m.%d")}."

    [time_string, @text, deadline]
  end


  # Метод для получения хэша и сохранения в БД новой записи
  def to_db_hash
    # Получаем предзаполненных родительских классом хэш и добавляем туда значения дочернего класса
    return super.merge(
      {
        "text" => @text,
        "due_date" => @due_date.to_s
      }
    )
  end


  # Метод для наполнения объекта данными из базы данных
  def load_data(data_hash)
    # Сперва вызываем родительский метод
    super(data_hash)

    # Затем наполняем свои специфичные поля
    @due_date = Date.parse(data_hash["due_date"])
    @text = data_hash["text"].split("\n\r")
  end

end